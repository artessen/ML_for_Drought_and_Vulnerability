# Loading the required libraries
library(caret)
library(ggplot2)
library(ggplotify)
library(hrbrthemes)
library(parallel)
library(gridExtra)
library(corrplot)
library(factoextra)
library(FactoMineR)
library(fitdistrplus)
library(reshape2)
library(abind)

# ==============================================================================
# Defining the number of bootstrapped data
nBoot = 10000

# Defining the function to revert the PCs to the original data
fPCArev = function(pca, x) {
  if (missing(x)) { x = pca$x }
  return (t(t(x %*% t(pca$rotation)) * pca$scale + pca$center))
}

# Loading the data
dfData = read.csv("Yearly_Summary_ADM2.csv")

# Keeping only the data that has no missing values, and dropping ntl variable
dfDatabasePCA = dfData[,!names(dfData) %in% c("ntl")]
dfDatabasePCA = na.omit(dfDatabasePCA)

# Selecting the unique codes of IDs for processing
sADM1id = c("ADM0_CODE","ADM1_CODE","ADM0_NAME","ADM1_NAME")
sADM2id = c("ADM0_CODE","ADM1_CODE","ADM2_CODE","ADM0_NAME","ADM1_NAME","ADM2_NAME")
dfPCAids = unique(dfDatabasePCA[,names(dfDatabasePCA) %in% sADM1id])

# For every unique ADM1, do...
dfPCAidADM1 = NULL
lBootResADM1 = NULL
for (iADM1 in 1:NROW(dfPCAids)) {
  
  # Processing
  message("Processing the group ", iADM1, " out of ", NROW(dfPCAids))
  
  # Selecting the data for the PCA (based on ADM1)
  dfPCAdata = subset(dfDatabasePCA, (ADM0_CODE==dfPCAids$ADM0_CODE[iADM1] & 
                                       ADM1_CODE==dfPCAids$ADM1_CODE[iADM1] & 
                                       ADM0_NAME==dfPCAids$ADM0_NAME[iADM1] &
                                       ADM1_NAME==dfPCAids$ADM1_NAME[iADM1]))
  dfPCAid = dfPCAdata[,(names(dfPCAdata) %in% c(sADM2id, "Year"))]
  dfPCAdata = dfPCAdata[,!(names(dfPCAdata) %in% c(sADM2id, "Year"))]
  
  # Computing the principal components
  PCAdata = prcomp(dfPCAdata, center=TRUE, scale=TRUE)
  
  # Generating the bootstrapped list of data
  nPCs = NCOL(PCAdata$x)
  lBootData = array(0, dim=c(nBoot, dim(PCAdata$x)))
  pb = txtProgressBar(min=1, max=nPCs, initial=1, style=3) 
  for (i in 1:nPCs) {
    x = PCAdata$x[,i]
    lBootData[,,i] = matrix(sample(x,size=length(x)*nBoot,replace=TRUE),nrow=length(x),ncol=nBoot)
    setTxtProgressBar(pb,i)
  }
  
  # Computing the reversed transformed bootstrapped data results
  lBootRes = array(NA, dim=c(nBoot, dim(dfPCAdata)))
  pb = txtProgressBar(min=1, max=nBoot, initial=1, style=3) 
  for (i in 1:nBoot) {
    # Computing the reversed values
    dfPCArev = as.data.frame(fPCArev(PCAdata, lBootData[i,,]))
    # Applying the physical boundaries to the transformed data
    dfPCArev$asi[dfPCArev$asi < 0] = 0; dfPCArev$asi[dfPCArev$asi > 100] = 100
    dfPCArev$era5land_tp[dfPCArev$era5land_tp < 0] = 0
    dfPCArev$gws[dfPCArev$gws < 0] = 0; dfPCArev$gws[dfPCArev$gws > 100] = 100
    dfPCArev$rtzsm[dfPCArev$rtzsm < 0] = 0; dfPCArev$rtzsm[dfPCArev$rtzsm > 100] = 100
    dfPCArev$sfsm[dfPCArev$sfsm < 0] = 0; dfPCArev$sfsm[dfPCArev$sfsm > 100] = 100
    # Storing the results to the list
    lBootRes[i,,] = as.matrix(dfPCArev)
    setTxtProgressBar(pb,i)
  }
  gc()
  
  # Combining the results
  dfPCAidADM1 = rbind(dfPCAidADM1, dfPCAid)
  lBootResADM1 = abind(lBootResADM1, lBootRes, along=2)
  cat("\n")
  
}

# Saving the results to the disk
write.csv(dfPCAidADM1, "boostrapped_data_IDs.csv", row.names=F)
saveRDS(lBootResADM1, file="boostrapped_data_10000samples.RData")
